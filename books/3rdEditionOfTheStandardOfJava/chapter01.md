# Chapter 01 자바를 시작하기 전에

## 1. 자바(Java Programming Language)

### 1.1 자바란?

자바는 썬 마이크로시스템즈(Sun Microsystems Inc.)에서 개발하여 1996년 1월에 공식적으로 발표한 객체지향 프로그래밍 언어입니다. 자바의 가장 중요한 특징은 운영체제(Operating System, 플랫폼)에 독립적이라는 것입니다. 자바로 작성된 프로그램은 운영체제의 종류에 관계없이 실행이 가능하기 때문에, 운영체제에 따라 프로그램을 전혀 변경하지 않고도 실행이 가능합니다.

2010년에 썬 마이크로시스템즈는 오라클사(Oracle Inc.)에 인수되면서 이제 자바는 오라클사의 제품이 되었습니다.



### 1.2 자바의 역사

- 1991년 썬의 엔지니어들에 의해 고안된 오크(Oak)라는 언어에서부터 시작
- 오크를 가전제품이나 PDA에 사용할 목적이었으나 인터넷에 적합하도록 개발하면서 Java로 이름을 변경
- 1996년 1월에 자바의 정식 버전을 발표
- 그 당시 애플릿(Applet)은 정적인 웹페이지에 다양한 컨텐츠를 요소를 제공하여 크게 유행
- 그 이후 서블릿(Servlet)과 JSP(Java Server Pages)가 등장하고 스마트폰의 운영체제인 안드로이드가 등장



### 1.3 자바 언어의 특징

1. **운영체제에 독립적**
   자바가상머신(JVM)에 의해 운영체제와 하드웨어에 관계없이 실행 가능합니다.
2. **객체지향언어**
   객체지향언어의 특징인 상속, 캡슐화, 다형성이 잘 적용된 순수한 객체지향언어라는 평가를 받고 있습니다.
3. **비교적 배우기 쉬움**
   C++에 비해 객체지향언어의 특징인 재사용성과 유지보수의 용이성 등의 장점을 극대화할 수 있습니다.
4. **자동 메모리 관리(Garbage Collection)**
   가비지컬렉터(Garbage collector)가 자동적으로 메모리를 관리해주기 때문에 메모리 관리를 따로 하지 않아도 됩니다.
5. **네트워크 분산처리를 지원**
   풍부하고 다양한 네트워크 프로그래밍 라이브러리(Java API)를 지원합니다.
6. **멀티쓰레드 지원**
   운영체제와 관계없이 멀티쓰레드 구현이 가능하고 관련된 다양한 라이브러리를 지원합니다. 
   그리고 여러 쓰레드에 대한 스케줄링(Scheduling)을 자바 인터프리터가 담당합니다.
7. **동적 로딩(Dynamic Loading) 지원**
   실행 시에 모든 클래스가 로딩 되지 않고 필요한 시점에 로딩하여 사용할 수 있습니다.



### 1.4 JVM(Java Virtual Machine)

가상 기계(Virtual Machine)은 소프트웨어로 구현된 하드웨어를 뜻하는 넓은 의미의 용어입니다. 이와 마찬가지로 가상 컴퓨터(Virtual Computer)는 실제 컴퓨터(하드웨어)가 아닌 소프트웨어로 구현된 컴퓨터라는 뜻으로 컴퓨터 속의 컴퓨터라고 생각하면 됩니다.

자바로 작성된 애플리케이션은 모두 이 가상 컴퓨터(JVM)에서만 실행되기 때문에, 자바 애플리케이션이 실행되기 위해서는 반드시 JVM이 필요합니다. 일반 애플리케이션에 비해 자바 애플리케이션은 JVM을 한 번 더 거치고, 완전히 컴파일된 상태가 아니기 때문에 실행 시에 해석(Interpret)되기 때문에 다른 언어에 비해 속도가 느리다는 단점이 있습니다.다음 그림은 JVM 애플리케이션과 일반 애플리케이션의 비교입니다. 

자바의 단점으로는 속도 문제가 가장 대표적입니다. 바이트 코드(Byte Code)를 하드웨어의 기계어로 바로 변환해주는 JIT 컴파일러와 Hotspot과 같은 신기술의 도입으로 JVM의 기능이 향상됨으로써 속도 문제가 상당히 개선되었습니다. 

![image-20231020022318353](C:\Users\piay8\AppData\Roaming\Typora\typora-user-images\image-20231020022318353.png)

<center> Java애플리케이션과 일반 애플리케이션의 비교 </center>



자바는 운영체제에 독립적이라는 가장 큰 특징이 있습니다. 그 이유는 운영체제마다 JVM을 제공하고 있기 때문입니다. Java 애플리케이션은 JVM하고만 상호작용하고 운영체제와 하드웨어에 독립적이며 JVM은 운영체제에 종속적이기 때문에 해당 운영체제에서 실행 가능한 JVM이 필요합니다.

![img](https://blog.kakaocdn.net/dn/cNKlJC/btrbACaQdVL/36GKfhPDXi6hvQnygoQr40/img.png)

<center> 다양한 OS 용 JVM </center>



## 2. 자바개발환경 구축하기

설치는 넘어가도록 합니다.

JDK를 설치하면 자바가상머신(Java Virtual Machine, JVM)과 자바클래스 라이브러리(Java API)외에 자바를 개발하는데 필요한 프로그램들이 설치됩니다. 다음은 JDK 버전입니다.

> - JDK 1.5 = JDK 5.0
> - JDK 1.7 = JDK 7.0
> - JDK 1.8 = JDK 8.0

JDK 설치 후 설치된 디렉토리의 bin 디렉토리( 예: `c:\jdk1.8\bin`)를 Path에 추가해주어야 합니다. 이 디렉토리에는 자바로 프로그램을 개발하는데 필요한 실행파일들이 들어있습니다. Path는 OS가 파일의 위치(디렉토리)를 파악하는데 사용하는 경로(Path)로, Path에 디렉토리를 등록하면, 해당 디렉토리에 포함된 파일을 파일 경로없이 파일 이름만으로도 사용할 수 있게 됩니다.

 

**JDK의 bin디렉토리에 있는 주요 실행파일들**

`javac.exe` : 자바 컴파일러. 자바 소스 코드를 바이트 코드로 컴파일

```cmd
c:\jdk1.8\work>javac Hello.java
```



`java.exe`: 자바 인터프리터. 컴파일러가 생성한 바이트 코드를 해석하고 실행

```cmd
c:\jdk1.8\work>java Hello
```



`javap.exe` : 역 어셈블러. 컴파일된 클래스 파일을 원래의 소스로 변환

```cmd
c:\jdk1.8\work>javap Hello > Hello.java
```

위와 같이 하면 Hello.class파일이 역컴파일되어 Hello.java에 저장됩니다. 그러나 원래의 소스 전체가 아닌 선언부만 저장될 뿐입니다. 
`'-c'`옵션을 이용하면, 바이트코드로 컴파일된 내용도 볼 수 있습니다.

\* **바이트 코드** : JVM이 이해할 수 있는 기계어입니다. JVM은 바이트코드를 해당 OS의 기계어로 변환하여 OS로 전달합니다.

 

`javadoc.exe` : 자동문서생성기. 소스파일에 있는 주석(`/** */`)을 이용하여 Java API문서와 같은 형식의 문서를 자동으로 생성

```cmd
c:\jdk1.8\work>javadoc Hello.java
```



`jar.exe` : 압축프로그램. 클래스파일과 프로그램의 실행에 관련된 파일을 하나의 jar파일(.jar)로 압축하거나 압축 해제합니다.

```java
//압축할 때
c:\jdk1.8\work>jar cvf Hello.jar Hello1.class Hello2.class

 
//압축 풀 때
c:\jdk1.8\work>jar xvf Hello.jar
```



 **JDK와 JRE**

| 구분 | 설명                                                         | 특징                                       |
| ---- | ------------------------------------------------------------ | ------------------------------------------ |
| JDK  | 자바개발도구(Java Development Kit)                           | JRE + 개발에 필요한 실행파일(javac.exe 등) |
| JRE  | 자바실행환경(Java Runtime Environment),<br /> 자바로 작성된 응용프로그램이 실행되기 위한 최소환경 | JVM + 클래스라이브러리(Java API)           |





## 3. 자바로 프로그램작성하기

### 3.1 Hello.java

```java
class Hello {
	public static void main(String[] args) {
    	System.out.println("Hello, world.");	//화면에 글자를 출력한다.
    }
}
```

이 예제는 화면에 'Hello, world.'를 출력하는 아주 간단한 프로그램입니다. 가장 먼저 자바 컴파일러(javac.exe)를 사용해서 소스파일(Hello.java)로부터 클래스파일(Hello.class)을 생성합니다. 그 다음에 자바 인터프리터(java.exe)로 실행하게 됩니다.

![img](https://blog.kakaocdn.net/dn/dBn5FO/btrbEMRu7UT/I5TUTSDt0R1pnC4PDtJGp0/img.png)



자바에서 모든 코드는 반드시 클래스 안에 존재해야 하며, 서로 관련된 코드들을 그룹으로 나누어 별도의 클래스를 구성하게 됩니다.
그리고 이 클래스들이 모여 하나의 Java 애플리케이션을 구성합니다.

 

클래스를 작성하는 방법은 키워드 'class' 다음에 클래스의 이름을 작성하고, 클래스의 시작과 끝은 의미하는 괄호`{ }` 안에 원하는 코드를 넣으면 됩니다.

```javascript
class 클래스이름 {
	/* 주석을 제외한 모든 코드는 클래스의 블럭 { } 내에 작성해야 한다. */
}
```



아래 코드의 `'public static void main(String[] args)'`는 main메서드의 선언부인데, 프로그램을 실행할 때 'java.exe'에 의해 호출될 수 있도록 미리 약속된 부분이므로 항상 똑같이 적어주어야 합니다.

\* `'[]'`은 배열을 의미하는 기호로 배열의 타입(type) 또는 배열의 이름 옆에 붙일 수 있습니다.
`'String[] args'`는 String타입의 배열 args를 선언한 것이며, `'String args[]'`와 같이 쓸 수도 있습니다.

```java
class 클래스이름{
	public static void main(String[] args) { //main 메서드의 선언부 
    	//실행될 문장들을 적는다.
    }
}
```

main 메서드의 선언부 다음에 나오는 괄호`{}`는 메서드의 시작과 끝을 의미하며, 이 괄호 사이에 작업할 내용을 작성해 넣으면 됩니다. Java 애플리케이션은 main메서드의 호출로 시작해서 main메서드의 첫 문장부터 마지막 문장까지 수행을 마치면 종료됩니다.

 

모든 클래스가 main메서드를 가지고 있어야 하는 것은 아니지만, **하나의 Java 애플리케이션에는 main 메서드를 포함한 클래스가 반드시 하나는 있어야 합니다.** main메서드는 Java 애플리케이션의 시작점이므로 main메서드 없이는 Java 애플리케이션은 실행될 수 없기 때문입니다. 작성된 Java애플리케이션을 실행할 때는 'java.exe' 다음에 main메서드를 포함한 클래스의 이름을 적어줘야 합니다.

 

하나의 소스 파일에 하나의 클래스만을 정의하는 것이 보통이지만, 하나의 소스 파일에 둘 이상의 클래스를 정의하는 것도 가능합니다. 이 때 주의해야할 점은 **'소스파일의 이름은 public class의 이름과 일치해야 한다.'**라는 것 입니다. 만일 소스파일 내에 **public class가 없다면, 소스파일의 이름은 소스파일 내의 어떤 클래스의 이름으로 해도 상관없습니다.**

```java
/* 소스파일의 작성 예 */

Hello2.java
//public class가 있는 경우, 소스파일의 이름은 반드시 public class의 이름과 일치해야 한다.
public class Hello2 {}
class Hello3 {}

hello2.java
//public class가 하나도 없는 경우, 소스파일의 이름은 'Hello2.java', 'Hello3.java' 둘 다 가능하다.
class Hello2 {}
class Hello3 {}
//---------------------------------------------------------------------------------------
Hello2.java
//하나의 소스파일에 둘 이상의 public class가 존재하면 안된다.
//각 클래스를 별도의 소스파일에 나눠서 저장하던가 아니면 둘 중의 한 클래스에 public을 붙이지 않아야 한다.
public class Hello2 {}
public class Hello3 {}

Hello3.java
//소스파일의 이름이 public class의 이름과 일치해야하기 때문에 'Hello2.java'로 변경해야 한다.
public class Hello2 {}
class Hello3 {}

hello2.java
//소스파일의 이름과 public class의 이름이 일치하지 않기 때문에 'Hello2.java'로 변경해야 한다.
//대소문자를 구분하므로 대소문자까지 일치해야 한다.
public class Hello2 {}
class Hello3 {}
```

소스파일(\*.java)과 달리 클래스파일(\*.class)은 클래스마다 하나씩 만들어지므로 첫 번째 'Hello2.java'를 컴파일하면 'Hello2.class'와 'Hello3.class' 모두 두 개의 클래스파일이 생성됩니다.

 

### 3.2 자주 발생하는 에러와 해결방법

**1. cannot find symbol 또는 cannot resolve symbol**
**지정된 변수나 메서드를 찾을 수 없는 경우**입니다. 선언되지 않은 변수나 메서드를 사용하거나, 변수 또는 메서드의 이름을 잘못 사용한 경우에 발생합니다. 자바에서는 대소문자 구분을 하기 때문에 철자 뿐만 아니라 대소문자의 일치 여부도 꼼꼼하게 확인해야 합니다.

**2. ';' expected**
**세미콜론 `';'`이 필요한 곳에 없는 경우**입니다. 자바의 모든 문장의 끝에는 `';'`을 붙여주어야 합니다.

**3. Exception in thread "main" java.lang.NoSuchMethodError: main**
**main 메서드를 찾을 수 없는 경우**입니다. 클래스 내에 main메서드가 존재하지 않거나 메서드의 선언부 `'public static void main(String[] args)'`에 오타가 존재하는 경우에 발생한 경우입니다. 해결 방법은 main메서드가 클래스에 정의되어 있는지 확인하고, 정의되어 있다면 main메서드의 선언부에 오타가 없는지 확인합니다. 자바는 대소문자를 구별하므로 대소문자의 일치 여부까지 정확히 확인해야 합니다.

\* args는 매개변수의 이름이므로 args 대신 argv나 arg와 같이 다른 이름을 사용할 수 있습니다.

**4. Exception in thread "main" java.lang.NoClassDefFoundError: Hello**
**Hello라는 클래스를 찾을 수 없는 경우**입니다. 클래스 'Hello'의 철자, 특히 대소문자를 확인해보고 이상이 없으면 클래스파일(*.class)이 생성되었는지 확인합니다. 'Hello.java'가 정상적으로 컴파일 되었다면 클래스파일 'Hello.class'가 있어야 합니다. 클래스파일이 존재하는데도 동일한 메시지가 반복해서 나타난다면 클래스패스(classpath)의 설정이 바르게 되었는지 확인합니다.

 

**5. illegal start of expression**
문장(또는 수식, expression)의 앞부분이 문법에 맞지 않는 경우 = 문장에 문법적 오류가 있는 경우입니다. 괄호 `'(`'나 `'{'`를 열고서 닫지 않거나, 수식이나 if문, for문 등에 문법적 오류가 있을 때 또는 public이나 static과 같은 키워드를 잘못 사용한 경우에 발생합니다.

 

**6. class, interface, or enum expected**
키워드 class나 interface 또는 enum이 없는 경우입니다. 보통 괄호 `'{'` 또는 `'}'`의 개수가 일치 하지 않는 경우에 발생. 열린괄호 `'{'`와 닫힌괄호 `'}'`의 개수가 같은지 확인합니다.

 

**에러가 발생했을 때 처리 순서**

1. 에러 메시지를 잘 읽고 해당 부분의 코드를 살펴본다. 이상이 없으면 해당 코드의 주위(윗줄과 아래 줄)도 함께 살펴본다.
2. 그래도 이상이 없으면 에러 메시지는 잊어버리고 기본적인 부분을 재확인한다. 대부분의 에러는 사소한 것인 경우가 많다.
3. 의심이 가는 부분을 주석처리하거나 따로 떼어내서 테스트 한다.

 

### 3.3 자바프로그램의 실행과정

![img](https://blog.kakaocdn.net/dn/cbWsIZ/btrbJJztj8f/HVBUVMgbSCteMf2NkTkKR1/img.png)

**main 메서드의 첫 줄부터 코드가 실행되기 시작하여 마지막 코드까지 모두 실행되면 프로그램이 종료되고, 프로그램에서 사용했던 자원들은 모두 반환**됩니다. 콘솔에서 위와 같이 Java 애플리케이션을 실행시켰을 때 내부적인 진행순서는 다음과 같습니다.

1. 프로그램의 실행에 필요한 클래스(*.class파일)를 로드한다.
2. 클래스파일을 검사한다. (파일형식, 악성코드 체크)
3. 지정된 클래스(Hello)에서 main(String[] args)를 호출한다.



### 3.4 주석(comment)

주석을 이용해 프로그램 코드에 대한 설명을 적절히 덧붙여 놓으면 프로그램을 이해하는 데 많은 도움이 됩니다.
그 외에도 주석은 프로그램의 작성자, 작성일시, 버전과 그에 따른 변경이력 등의 정보를 제공할 목적으로 사용됩니다.

```java
/* 범위 주석 */
//한 줄 주석
```

문자열을 의미하는 큰따옴표(") 안에 주석이 있을 때는 주석이 아닌 문자열로 인식된다.

```java
class Hello {
	public static void main(String[] args) {
    	System.out.println("Hello, /* 이것은 주석 아님 */ world.");
        System.out.println("Hello, world. //이것은 주석 아님");
    }
}
```