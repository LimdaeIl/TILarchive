# 1장 자바 시작하기


> 1.1 프로그래밍 언어와 자바
>
> 1.2 자바 개발 환경(생략)~
>
> 1.3 자바 프로젝트(생략)
>
> 1.4 자바 프로그램의 기본 구조



## 1.1 프로그래밍 언어와 자바

**프로그래밍 언어**

- 프로그래밍 언어는 컴퓨터가 이해할 수 있는 명령을 작성하기 위한 도구를 의미한다.

컴퓨터는 0과 1만 이해할 수 있고 사람의 말은 이해할 수 없습니다. 따라서 Java, C, C++ 같은 프로그래밍 언어를 사용해야 합니다. 이처럼 프로그래밍 언어들은 기계어로 변경되고 컴퓨터에 전달이 됩니다. 프로그래밍 언어가 사람의 말에 가까운 지에 따라서 크게 고급 언어, 어셈블리어, 기계어로 나뉘게 됩니다. 

**고급 언어**

- 고급 언어는 인간이 이해하기 쉬운 문장을 사용해 컴퓨터가 수행해야 할 작업을 정의한 언어로, C, C++, Java 등이 있다.

**기계어**

- 기계어는 2진 데이터(0010100100111...)으로 구성돼 있어 컴퓨터가 직접 알아들을 수 있는 언어를 말합니다.

**어셈블리어**

- 고급 언어와 기계어 사이에는 어셈블리어가 있다. 어셈블리어는 기계어와 1 대 1로 대응되는 언어로, 굳이 따지면 기계어와 좀 더 가깝다고 할 수 있다.

Java를 비롯한 고급 언어는 사람이 이해하기 쉬운 문장으로 구성돼 있습니다. 그러나 컴퓨터는 이 언어를 바로 이해하지 못합니다. 따라서 컴퓨터가 이해할 수 있는 언어로 변환하는 과정이 필요한데, 이 과정을 수행하기 위해 **컴파일러(Compiler)**가 필요합니다. 프로그램을 언어의 관점으로 볼 때, 컴파일러는 "번역기" 정도로 이해하면 될 것입니다.



🌈 **모든 컴퓨터는 똑같은 기계어를 사용할까?**

기계어를 "컴퓨터가 이해할 수 있는 언어"라고 했습니다. 이 때 중요한 점은, "모든 컴퓨터는 똑같은 기계어를 사용할까?" 입니다. 정답은 "아닙니다." 왜냐하면, 컴퓨터는 자신의 플랫폼에 따라 서로 다른 언어를 사용하고 있습니다. 예를 들어 Windows 컴퓨터와 Mac 컴퓨터는 서로 다른 기계어를 사용합니다. 따라서 동일한 고급 언어로 작성된 프로그램이라 하더라도 다른 플랫폼상에서 동작하도록 하기 위해서는 다른 컴파일러를 사용해야 합니다. 핵심 포인트는 다른 프로그래밍 언어들과 비교해 자바가 지니고 있는 가장 큰 장점인 "플랫폼 독립성" 이라는 개념을 이해하는 데 필수적인 사항이므로 반드시 기억해야 합니다.



### 1.1.2 자바의 역사

- 자바의 전신은 1991년 가전 제품의 셋톱(settop)용 프로그램으로 만든 오크(oak).
- 1995년 "핫 자바(hot java)"라는 웹 브라우저를 자바로 개발해 발표.
- 1996년 자바 1.0을 정식 발표하면서 버전을 지속적으로 업그레이드하여 2014년에 자바 8을 발표하고 지속적으로 업데이트를 진행.



**1.1.3 자바의 플랫폼 독립성**

> Write Once, Run Anywhere (한 번 작성하면 어느 플랫폼에서나 실행)
>
> 자바의 좌우명

플랫폼 독립성, 객체지향 언어, 함수형 코딩 지원, 분산 처리 지원, 멀티 쓰레드 지원 등 여러 가지 특징을 지닌 프로그래밍 언어입니다.
자바의 가장 큰 특징은 "플랫폼 독립성"입니다. 



**플랫폼 종속성, 플랫폼 독립성이란?**

- **플랫폼**은 응용 프로그램을 실행하는 데 쓰이는 하드웨어와 소프트웨어의 결합을 의미한다.
- **플랫폼 종속성**은 "하나의 실행 파일은 하나의 특정 플랫폼에서만 실행할 수 있다." 는 것을 의미한다.
- **플랫폼 독립성**은 "하나의 실행 파일이 모든 플랫폼에서 실행할 수 있다."는 것을 의미한다.

플랫폼 종속성의 대표적인 예는 윈도우, 맥, 리눅스 운영체제의 대표적인 실행 파일(.exe, .app, .sh)을 들 수 있습니다. 실행 파일은 일종의 "기계어 집합"입니다. 즉, 컴퓨터가 알아들을 수 있는 명령어들의 집합입니다. 앞에서 언급했듯이 서로 다른 플랫폼을 사용하는 컴퓨터는 서로 다른 기계어를 사용합니다. 즉, 다른 플랫폼에서 사용하는 기계어는 알아 듣지 못합니다.

윈도우의 실행 파일(.exe)을 맥, 리눅스와 같이 다른 플랫폼에서 실행하면 동작하지 않습니다. 또한 맥과 리눅스 실행 파일도 자신의 플랫폼에서만 실행이 가능합니다. 이러한 특징을 "플랫폼 종속성(Platform Dependence)"이라 합니다. 플랫폼 종속성을 이해하면 플랫폼 독립성(Patform Independence)를 쉽게 이해할 수 있습니다. 

자바 실행 파일(.class)도 특정 플랫폼안 이해할 수 있는 기계어의 집합입니다. 어떤 플랫폼과도 일치하지 않은 것처럼 보이지만, 자바가 플랫폼 독립성을 지닐 수 있는 이유는 바로 **자바 가상 머신(JVM)** 때문입니다. 다양한 플랫폼 위에 플랫폼에 적합한 자바 가상 머신이라는 도구를 설치하면 개발자는 플랫폼을 고려하지 않아도 됩니다. 이것이 바로 "**자바의 플랫폼 독립성**"입니다.



### 1.1.4 자바 개발 도구와 자바 실행 환경

- 자바 개발 도구(**JDK**, Java Development Kit)
  - 자바를 이용해 프로그램을 개발하는 데 필요한 도구를 모아 둔 집합.
- 자바 실행 환경(**JRE**, Java Runtime Evironment)
  - 완성된 프로그램을 실행하는 데 필요한 환경을 의미.
- 자바 가상 머신(**JVM**, Java Virtual Machine)
  - 자바 프로그램 실행 환경을 만들어 주는 소프트웨어.

<img src="C:\Users\piay8\AppData\Roaming\Typora\typora-user-images\image-20230823124154802.png" alt="image-20230823124154802" style="zoom:67%;" />

자바 개발 도구(JDK) 안에는 자바로 프로그램을 만들 때 도움을 주는 자바 개발 환경(JRE)이 포함되어 있습니다. 자바 개발 환경 안에는 자바 실행을 위한 자바 가상 머신이 있습니다. 자바 실행 파일(.class)는 자바 가상 머신 위에서만 실행할 수 있기 때문에 자바 실행을 위해서는 반드시 자바 가상 머신(JVM)을 설치해야 합니다. 정리하자면, JDK > JRE > JVM 순서로 포함 관계를 가지고 있습니다.



## 1.4 자바 프로그램의 기본 구조

1. 소스 파일(.java) 생성
   - 파일 저장 시 자동 컴파일을 수행합니다.
2. 바이트 코드(.class) 파일로 변환
   - JVM에서 동작하는 바이트 코드(.class) 파일로 변환합니다.
3. JVM에서 메모리 할당
   - JVM은 운영체제에서 메모리를 할당받아 메서드 영역에 클래스를 로딩합니다.
4. main() 메서드 실행
   - `System.out.println("화면 출력")` 을 실행합니다.



🌈 **자바 가상 머신(JVM)이 할당한 메모리 영역?**

자바 가상 머신은 메모리를 효율적으로 관리하기 위해 메모리를 크게 메서드(Method) 영역, 스택(Stack) 영역, 힙(Heap) 영역으로 나눠서 사용합니다. 이 때, 메서드 영역은 클래스(class), 정적(static), 상수(final) 영역이라고도 부릅니다. 운영체제에 의해 메모리 할당된 이후, 실행 파일인 바이트 코드는 메모리의 메서드 영역에 로딩되며, 이후 클래스 내에 포함돼 있는 main() 메서드를 실행하는 것이 자바 가상 머신의 역할입니다. 따라서 자바에서는 main() 메서드가 자바 프로그램의 시작 지점이자 끝 지점을 의미합니다.

1. 메서드(Method) 영역
   - 메서드 영역의 동의어 :arrow_right: 클래스(Class), 정적(Static), 상수(Final) 영역
2. 스택(Stack) 영역
3. 힙(Heap) 영역

각 영역이 운영체제에 의해 할당되고 존재한다는 것만 이해하고 넘어갑니다.



### 1.4.2 소스 코드의 기본 구조 분석

- 주석(Comment)은 메모의 기능을 수행하고 프로그램의 가독성을 높이는 데 사용
- 한 줄을 주석 처리할 때, `//`
- 여러 줄을 주석 처리할 때, `/* */` 

```java
/*
	여러 줄 주석 작성하기 
	여러 줄 주석 작성하기 
	여러 줄 주석 작성하기 
*/
```

| 줄 수     | 형식                       | 단축키             |
| --------- | -------------------------- | ------------------ |
| 1 줄      | `// 한 줄 주석하기`        | `Ctrl + /`         |
| 2 줄 이상 | `/* 여러 줄을 주석하기 */` | `Ctrl + Shift + /` |



**패키지 선언부**

- 패키지를 선언하는 경우, 코드에서 주석을 제외한 **첫 줄에 반드시 패키지의 선언**이 와야 한다.
- 패키지를 지정하지 않으면 디폴트 패키지를 사용하게 되는데, 패키지 선언이 생략된다.
  단순히, 패키지는 디렉터리입니다. 따라서 디폴트 패키지를 사용하는 것의 의미는 패키지 경로가 없다는 것 뿐이에요.

**클래스 선언부**

- `public` 접근 지정자는 **클래스를 다른 패키지에서도 사용할 수 있다는 의미**이다.
- 한 개의 소스 파일(.java) 안에 여러 개의 클래스가 있다고 가정할 때, **단 하나의 클래스만 `public` 접근 지정자를 선언할 수 있다.**
  메서드 앞에서는 `public`  선언이 여러 번 가능합니다. 클래스인 지 메서드인 지 구분해서 유의합니다.
- 클래스명은 반드시 소스 파일명과 일치해야 한다.
- 클래스명 뒤에 중괄호 `{}` 안에는 클래스 내부에 포함될 수 있는 내부 구성 요소를 작성한다.
  내부 구성 요소는 필드(Field), 메서드(Method), 생성자(Constructor), 이너 클래스(Inner class)로 4개이다.



- `Test.java` 소스 파일
  1. `public` 접근 지정자인 클래스 `Test`
  2. 소스 파일명(`Test.java`)과 클래스명(`Test`)이 동일

```java
 public class Test { 
    // 필드, 메서드, 생성자, 이너 클래스 작성이 가능
}
```



**main() 메서드**

- 메서드의 구조 :arrow_right: `[접근 지정자] [메모리영역] 리턴타입 메서드명([매개변수명1, 매개변수명2, ...]) {}`
- `main()` 메서드는 리턴(반환)타입은 `void`, 메서드명은 `main` 을 의미한다.
- 바이트 코드가 메서드 영역에 로딩되면 자바 가상 머신은 `main()` 메서드부터 실행한다.

```java
public static void main(Sring[] arg) {
    // 
}
```



### 1.4.3 생성 프로젝트의 기본 구조

- `JavaBasicStructure.java`

```java
package sec01_basicsyntax;

/*
	여러 줄 주석은 Ctrl + Shift + /
*/

public class JavaBasicStructure {
    public static void main(String[] args) {
        // 한 줄 주석은 Ctrl + / 
        System.out.println("콘솔 화면에 출력하기");
    }
}
```

핵심 포인트는 `public` 접근 지정자가 선언된 클래스명과 소스 파일명이 동일해야 하고, 단 하나의 클래스만 `public` 선언이 가능합니다.



### 1.4.4 콘솔 출력 메서드와 문자열 출력

지금까지 모두 간단하게 익혀보는 사용 방법과 이해를 가지는 시간으로 각 장마다 자세히 설명할 것이므로 가볍게 보고 넘어갑니다.



**문자열 표현하기**

- 문자열은 String 자료형으로 저장하고, 반드시 큰따옴표`""` 안에 표기.
  `"안녕", "반가워", "문자열은 큰따옴표 안에 작성하기"...`
- 문자열과 문자열을 더하거나 혹은 문자열과 기본 자료형을 더하면 다시 문자열이 되며, 연산 결과는 문자열을 연결한 형태.
  - `"안녕" + "반가워" = "안녕반가워"`
  - `"안녕" + 3 ="안녕3"`



**줄 바꾸면서 출력하기 - `System.out.println()`**

콘솔에 값을 출력하기 위해 다음과 같이 세 가지의 메서드를 사용해야 합니다.

1. `System.out.println()`

   :arrow_right: 소괄호 안의 내용을 출력하고 줄을 변경.

2. `System.out.print()` 

   :arrow_right: 소괄호 안의 내용을 출력하고 줄을 변경하지 않음.

3. `System.out.printf()` 

   :arrow_right: 출력 포맷(print format)을 지정하는 메서드.

```java
/* System.out.println() */
System.out.println("화면 출력");			// 화면 출력
System.out.println("화면" + "출력");		// 화면출력
System.out.println(3.8);					// 3.8
System.out.println(3 + 5);					// 8
System.out.println("화면" + 3);			// 화면3
System.out.println("화면" + 3 + 5);		// 화면35
System.out.println(3 + 5 + "화면");		// 8화면


/* System.out.println() - 변수에 넣어 출력하기*/
int a = 3;
String b = "화면";
System.out.println(a);				 // 3
System.out.println(b); 				// 화면
System.out.println(b + "출력"); 		// 화면출력
System.out.println(a + b + "출력"); // 3화면출력
```



```java
/* System.out.print() */
System.out.print("화면");
System.out.print("출력");
System.out.print(3);

/* 실행 결과 */
화면출력3

    
    
/* System.out.print() - 개행 문자 \n 추가 */
System.out.print("화면\n");
System.out.print("출력");

/* 실행 결과 */
화면
출력
```



```java
/* System.out.printf() */
System.out.printf("%d\n", 30);				// 30(10진수)
System.out.printf("%o\n", 30);				// 36(8진수)
System.out.printf("%xn", 30);				// 1e(16진수)
System.out.printf("%s\n", "출력");			// 출력
System.out.printf("%f\n", 5.8);				// 5.80000
System.out.printf("%4.2f\n", 5.8);			// 5.80
System.out.printf("%d와 %4.2f\n", 4, 5.8);	// 4와 5.80

```

